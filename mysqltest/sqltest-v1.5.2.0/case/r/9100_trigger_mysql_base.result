ALTER SYSTEM SET merge_delay_interval='6s' server_type=yaodatasvr;
ALTER SYSTEM SET major_freeze_wait_time='6s' server_type=yaoadminsvr;
ALTER SYSTEM SET  min_major_freeze_interval='5s' server_type=yaotxnsvr;
ALTER SYSTEM SET min_merge_interval='5s' server_type=yaodatasvr;
ALTER SYSTEM SET  max_merge_thread_num='20' server_type=yaodatasvr;
drop table if exists t1;
create table t1 (i int);
create trigger trg before insert on t1 for each row set @a:=1;
set @a:=0;
select @a;
@a
0
insert into t1 values (1);
select @a;
@a
1
drop trigger if exists trg;
drop table  if exists t1;
create table t1 (i int);
create trigger trg before insert on t1 for each row set @a:=new.i;
insert into t1 values (123);
select @a;
@a
123
drop trigger if exists trg;
drop table t1;
drop table  if exists t1;
create table t1 (i int not null, j int);
create trigger trg before insert on t1 for each row 
begin 
if new.j is NULL then
set new.j:= new.i * 10;
end if;
end|
insert into t1 (i) values (1)|
insert into t1 (i,j) values (2, 3)|
select * from t1|
i	j
1	10
2	3
drop trigger if exists trg|
drop table if exists t1|
drop table  if exists t1;
create table t1 (i int not null primary key);
create trigger trg after insert on t1 for each row 
set @a:= if(@a,concat(@a, ':', new.i), new.i);
set @a:='';
insert into t1 values (2),(3),(4),(5);
select @a;
@a
2:3:4:5
drop trigger if exists trg;
drop table  if exists t1;
create table t1 (aid int not null primary key, balance int not null default 0);
insert into t1 values (1, 1000), (2,3000);
create trigger trg before update on t1 for each row 
begin
declare loc_err varchar(255);
if abs(new.balance - old.balance) > 1000 then
set new.balance:= old.balance;
set loc_err := concat('Too big change for aid = ', new.aid);
set @update_failed:= if(@update_failed, concat(@a, ':', loc_err), loc_err);
end if;
end|
set @update_failed:='';
update t1 set balance=1500;
select @update_failed;
@update_failed
Too big change for aid = 2
select * from t1;
aid	balance
1	1500
2	3000
drop trigger if exists trg;
drop table  if exists t1;
create table t1 (i int);
insert into t1 values (1),(2),(3),(4);
create trigger trg after update on t1 for each row
set @total_change:=@total_change + new.i - old.i;
set @total_change:=0;
update t1 set i=3;
select @total_change;
@total_change
2
drop trigger if exists trg;
drop table  if exists t1;
create table t1 (i int);
insert into t1 values (1),(2),(3),(4);
create trigger trg before delete on t1 for each row 
set @del_sum:= @del_sum + old.i;
set @del_sum:= 0;
delete from t1 where i <= 3;
select @del_sum;
@del_sum
6
drop trigger if exists trg;
drop table  if exists t1;
create table t1 (i int);
insert into t1 values (1),(2),(3),(4);
create trigger trg after delete on t1 for each row set @del:= 1;
set @del:= 0;
delete from t1 where i <> 0;
select @del;
@del
1
drop trigger if exists trg;
drop table  if exists t1;
create table t1 (i int, j int);
create trigger trg1 before insert on t1 for each row 
begin
if new.j > 10 then
set new.j := 10;
end if;
end|
create trigger trg2 before update on t1 for each row 
begin
if old.i % 2 = 0 then
set new.j := -1;
end if;
end|
create trigger trg3 after update on t1 for each row 
begin
if new.j = -1 then
set @fired:= 'Yes';
end if;
end|
set @fired:='';
insert into t1 values (1,2),(2,3),(3,14);
select @fired;
@fired

select * from t1;
i	j
1	2
2	3
3	10
update t1 set j= 20;
select @fired;
@fired
Yes
select * from t1;
i	j
1	20
2	-1
3	20
drop trigger if exists trg1;
drop trigger if exists trg2;
drop trigger if exists trg3;
drop table if exists t1, t2, t3;
create table t1 (id int primary key, data varchar(10), fk int);
create table t2 (event varchar(100));
create table t3 (id int primary key);
create trigger t1_ai after insert on t1 for each row
insert into t2 values (concat('INSERT INTO t1 id=', new.id, ' data=', new.data, ';'));
insert into t1 (id, data) values (1, 'one'), (2, 'two');
select * from t1;
id	data	fk
1	one	NULL
2	two	NULL
select * from t2;
event
INSERT INTO t1 id=1 data=one;
INSERT INTO t1 id=2 data=two;
drop trigger if exists t1_ai;
drop table if exists t1, t2, t3;
create table t1 (id int primary key, data varchar(10), fk int);
create table t2 (event varchar(100));
create table t3 (id int primary key);
create trigger t1_bi before insert on t1 for each row
begin
if exists (select id from t3 where id=new.fk) then
insert into t2 values (concat('INSERT INTO t1 id=', new.id, ' data=', new.data, ' fk=', new.fk));
else
insert into t2 values (concat('INSERT INTO t1 FAILED id=', new.id, ' data=', new.data,  ' fk=' , new.fk));
set new.id= 100;
end if;
end|
insert into t3 values (1);
insert into t1 values (4, 'four', 1), (5, 'five', 2);
select * from t1;
id	data	fk
4	four	1
100	five	2
select * from t2;
event
INSERT INTO t1 id=4 data=four fk=1
INSERT INTO t1 FAILED id=5 data=five fk=2
drop trigger if exists t1_bi;
drop table if exists t1, t2,t3;
create table t1 (id int primary key, data varchar(10));
create table t2 (seq int);
insert into t2 values (10);
create function f1 () returns int return (select max(seq) from t2);|
create trigger t1_bi before insert on t1 for each row
begin
if new.id > f1() then
set new.id:= f1();
end if;
end|
insert into t1 values (1, 'first');
insert into t1 values (f1(), 'max');
select * from t1;
id	data
1	first
10	max
drop function f1;
drop table if exists t1, t2,t3;
create table t1 (id int primary key, fk_t2 int);
create table t2 (id int primary key, fk_t3 int);
create table t3 (id int primary key);
insert into t1 values (1,1), (2,1), (3,2);
insert into t2 values (1,1), (2,2);
insert into t3 values (1), (2);
create trigger t3_ad after delete on t3 for each row
delete from t2 where fk_t3=old.id;
create trigger t2_ad after delete on t2 for each row
delete from t1 where fk_t2=old.id;
delete from t3 where id = 1;
select * from t1 left join (t2 left join t3 on t2.fk_t3 = t3.id) on t1.fk_t2 = t2.id;
id	fk_t2	id	fk_t3	id
3	2	2	2	2
drop table if exists t1, t2,t3;
create table t1 (id int primary key, copy int);
create table t2 (id int primary key, data int);
insert into t2 values (1,1), (2,2);
create trigger t1_bi before insert on t1 for each row
set new.copy= (select data from t2 where id = new.id);
create trigger t1_bu before update on t1 for each row
set new.copy= (select data from t2 where id = new.id);
insert into t1 values (1,3), (2,4), (3,3);
select * from t1;
id	copy
1	1
2	2
3	NULL
update t1 set copy= 1 where id = 2;
select * from t1;
id	copy
1	1
2	2
3	NULL
drop table t1, t2;
drop table if exists t1, t2,t3;
drop trigger if exists trg;
create table t1 (i int);
create view v1 as select * from t1;
create trigger trg before insert on v1 for each row set @a:=1;
ERROR HY000: YAO-7015: test.v1 is not BASE TABLE
insert into t1 values(1);
select * from t1;
i
1
select * from v1;
i
1
drop view if exists v1;
drop table if exists t1;
create table t1(i int,j int);
create trigger trg before insert on t1 for each row set @a:= old.i;
ERROR HY000: YAO-7007: There is no OLD row in on INSERT trigger
drop table if exists t1;
create table t1 (x1col char);
create trigger tx1 before insert on t1 for each row set new.x1col = 'x';
insert into t1 values ('y');
select * from t1;
x1col
x
drop trigger tx1;
drop table t1;
drop table if exists t1;
create table t1 (i int);
insert into t1 values (1), (2);
create trigger trg1 before delete on t1 for each row set @del_before:= @del_before + old.i;
create trigger trg2 after delete on t1 for each row set @del_after:= @del_after + old.i;
set @del_before:=0, @del_after:= 0;
delete from t1;
select @del_before, @del_after;
@del_before	@del_after
3	3
drop trigger trg1;
drop trigger trg2;
drop table t1;
create table t1 (i int, j int default 10)|
create table t2 (i int)|
insert into t2 values (1), (2)|
create trigger trg1 before insert on t1 for each row 
begin
if new.i = 1 then
set new.j := 1;
end if;
end|
create trigger trg2 after insert on t1 for each row set @a:= 1|
set @a:= 0|
insert into t1 (i) select * from t2|
ERROR 0A000: YAO-7: unsupport insert into ... select with triggers[3028]
select * from t1|
i	j
select @a|
@a
0
drop table t1, t2|
create table t1 (col1 int, col2 int);
insert into t1 values (1, 2);
create function f1 () returns int return 5|
create trigger t1_bu before update on t1 for each row set new.col1= f1();
drop function f1;
update t1 set col2 = 4;
ERROR 25S03: YAO-119: Unknown function, error code = -5055
drop trigger t1_bu;
drop table t1;
set yao_decimal_add_zero=true;
create table t1(i int not null, j int not null, n numeric(15,2), primary key(i,j));
create table t2(i int not null, n numeric(15,2), primary key(i));
create trigger t1_ai after insert on t1 for each row
begin
declare sn numeric(15,2);
select sum(n) into sn from t1 where i=new.i;
replace into t2 values(new.i, sn);
end|
insert into t1 values
(1,1,10.00),(1,2,10.00),(1,3,10.00),(1,4,10.00),(1,5,10.00),
(1,6,10.00),(1,7,10.00),(1,8,10.00),(1,9,10.00),(1,10,10.00),
(1,11,10.00),(1,12,10.00),(1,13,10.00),(1,14,10.00),(1,15,10.00);
select * from t1;
i	j	n
1	1	10.00
1	2	10.00
1	3	10.00
1	4	10.00
1	5	10.00
1	6	10.00
1	7	10.00
1	8	10.00
1	9	10.00
1	10	10.00
1	11	10.00
1	12	10.00
1	13	10.00
1	14	10.00
1	15	10.00
select * from t2;
i	n
1	150.00
drop table t1, t2;
set yao_decimal_add_zero=false;
drop table if exists t1, t2;
create table t1 (i int, j int default 10, k int not null, key (k));
create table t2 (i int);
insert into t1 (i, k) values (1, 1);
insert into t2 values (1);
create trigger trg1 before update on t1 for each row set @a:= @a + new.j - old.j;
create trigger trg2 after update on t1 for each row set @b:= 'Fired';
set @a:= 0, @b:= '';
update t1 set j = j + 10 where t1.i =1;
select @a, @b;
@a	@b
10	Fired
insert into t1 values (2, 13, 2);
insert into t2 values (2);
set @a:= 0, @b:= '';
update t1 set j = j + 15 where t1.i = 1;
select @a, @b;
@a	@b
15	Fired
create trigger trg3 before delete on t1 for each row set @c:= @c + old.j;
create trigger trg4 before delete on t2 for each row set @d:= @d + old.i;
create trigger trg5 after delete on t1 for each row set @e:= 'After delete t1 fired';
create trigger trg6 after delete on t2 for each row set @f:= 'After delete t2 fired';
set @c:= 0, @d:= 0, @e:= '', @f:= '';
delete from t1 where t1.i = 1;
select @c, @d, @e, @f;
@c	@d	@e	@f
35	0	After delete t1 fired	
drop table t1, t2;
drop table  if exists t1;
create table t1 (c1 int, c2 datetime);
insert into t1 (c1) values (1),(2),(3);
select * from t1;
c1	c2
1	NULL
2	NULL
3	NULL
create procedure f11(x char(16))
begin
select 'hello';
select 'hello again';
end|
create trigger tr1 before insert on t1 for each row 
begin 
call f11(new.c2);
set new.c2= '2004-04-02';
end|
insert into t1 (c1) values (4),(5),(6);
ERROR 0A000: YAO-7: Not supported feature or function
select * from t1;
c1	c2
1	NULL
2	NULL
3	NULL
drop procedure f11;
drop table t1;
create table t1(i int,j int);
create trigger trg before insert on t1 for each row set @a:= old.i;
ERROR HY000: YAO-7007: There is no OLD row in on INSERT trigger
create trigger trg before delete on t1 for each row set @a:= new.i;
ERROR HY000: YAO-7007: There is no NEW row in on DELETE trigger
create trigger trg before update on t1 for each row set old.i:=1;
ERROR HY000: YAO-7009: can't set OLD variable new value
create trigger trg before delete on t1 for each row set new.i:=1;
ERROR HY000: YAO-7007: There is no NEW row in on DELETE trigger
create trigger trg after update on t1 for each row set new.i:=1;
ERROR HY000: YAO-7013: after trigger does not support this function
drop table t1;
create table t1 (i int not null, j int);
create trigger  trg before insert on t1 for each row 
begin 
if new.j is NULL then
set new.j:= new.i * 10;
end if;
end;|
insert into t1(i) values (1);
insert into t1(i,j) values (2, 3);
select * from t1;
i	j
1	10
2	3
show triggers;
Trigger	Event	Table	Statement	Timing	Created	sql_mode	Definer	character_set_client	collation_connection	Database Collation
trg	INSERT	t1	create trigger  trg before insert on t1 for each row 
begin 
if new.j is NULL then
set new.j:= new.i * 10;
end if;
end;	BEFORE	2025-1-23		admin@%	latin1	latin1_swedish_ci	utf8mb4_general_ci
drop trigger trg;
show triggers;
Trigger	Event	Table	Statement	Timing	Created	sql_mode	Definer	character_set_client	collation_connection	Database Collation
CREATE TABLE t(c1 INT);
CREATE TABLE msg(c1 INT AUTO_INCREMENT PRIMARY KEY, c2 VARCHAR(100));
CREATE TRIGGER IF NOT EXISTS trg1_t BEFORE INSERT ON t FOR EACH ROW
BEGIN
INSERT INTO msg(c2) VALUES ('BEFORE INSERT trg1_t');
END;
|
CREATE TRIGGER trg2_t BEFORE INSERT ON t FOR EACH ROW FOLLOWS trg1_t
BEGIN
INSERT INTO msg(c2) VALUES ('BEFORE INSERT trg2_t');
END;
|
CREATE TRIGGER trg3_t BEFORE INSERT ON t FOR EACH ROW FOLLOWS trg1_t
BEGIN
INSERT INTO msg(c2) VALUES ('BEFORE INSERT trg3_t');
END;
|
CREATE TRIGGER trg4_t BEFORE INSERT ON t FOR EACH ROW PRECEDES trg1_t
BEGIN
INSERT INTO msg(c2) VALUES ('BEFORE INSERT trg4_t');
END;
|
INSERT INTO t VALUES (1);
SELECT * FROM msg;
c1	c2
1	BEFORE INSERT trg4_t
2	BEFORE INSERT trg1_t
3	BEFORE INSERT trg3_t
4	BEFORE INSERT trg2_t
