--source merge.sql
##############################################################################################
###1.测试功能点：测试HotRelease-V1.4.0.0-202405分支修复合并的相关issue
#                         
#                 
#
###2.测试项：(每新添一测试项，需在添加前注明测试项，注释填写在新添sq1前，不填在此处，如下样例）
###3.问题网址：
###4.问题号：
###5.预计运行时间：15s
###6.编写/修改人：zhangt
###7.编写/修改日期：
###8.其他（选填）：新增
###
##
#
##############################################################################################

#####################################Do sql###################################################
alter system set balance_max_concurrent_migrate_num=30 server_type=yaoadminsvr;
alter system set balance_max_migrate_in_per_ds=6 server_type=yaoadminsvr;
alter system set balance_max_migrate_out_per_ds=6 server_type=yaoadminsvr;
alter system set max_migrate_task_count=6 server_type=yaodatasvr;
###2-1:ISSUE15 case_when
create table t1(c1 int, c2 int, c3 int, c4 int, c5 int);
insert into t1 values(1,2,3,4,5),(1,3,2,5,4),(2,1,3,4,5);
create table t(c1 int);insert into t values(1),(2),(3),(4);
CREATE TABLE `t3` (`c1` int NOT NULL, `c2` int DEFAULT NULL,`c3` int DEFAULT NULL, PRIMARY KEY (`c1`));
CREATE TABLE `t4` (`c1` int NOT NULL, `c2` int DEFAULT NULL,`c3` int DEFAULT NULL,PRIMARY KEY (`c1`));
insert into t3 values(1,1,2),(2,2,2),(3,6,8);
insert into t4 values(1,2,3),(2,4,5),(3,6,8);
CREATE TABLE products (
  productID int NOT NULL,
  productName varchar(255) DEFAULT NULL,
  categoryID int DEFAULT NULL,
  unitPrice int DEFAULT NULL,
  stockQuantity int DEFAULT NULL,
  PRIMARY KEY (productID)
);

INSERT INTO `products` VALUES (1, 'Laptop', 1, 800, 50);
INSERT INTO `products` VALUES (2, 'Smartphone', 1, 500, 100);
INSERT INTO `products` VALUES (3, 'T-shirt', 2, 20, 200);
INSERT INTO `products` VALUES (4, 'Jeans', 2, 40, 150);
INSERT INTO `products` VALUES (5, 'Headphones', 1, 100, 75);
INSERT INTO `products` VALUES (6, 'Backpack', 1, 60, 80);
INSERT INTO `products` VALUES (7, 'Sneakers', 2, 50, 120);
INSERT INTO `products` VALUES (8, 'Watch', 3, 150, 30);
INSERT INTO `products` VALUES (9, 'Sunglasses', 3, 40, 90);
#参数测试
select CASE 'b' when 'a' then 1 when 'b' then 2 END;
select case when 1>0 then 'TRUE' else 'FALSE' END;
select case when 1>2 then 'TRUE'  END;
#--error 5023
select case c1 when 'c' then '1' end from t1;
#算术运算、比较/逻辑/连接运算符
select 1 + (CASE 1 when 1 then 1+2 WHEN 2 then 2 END) + 2 as res;
select 1 + (CASE 1 when 1 then 1-2 WHEN 2 then 2 END) + 2 as res;
select 2 * (CASE 1 when 1 then 1*2 WHEN 2 then 2 END) * 2 as res;
select 2 * (CASE 1 when 1 then 3/2 WHEN 2 then 2 END) * 2 as res;
select * from t where c1 < case when c1%2=0 then c1*c1 else c1/c1 end;
select * from t where c1 > case when c1%2=0 then c1*c1 else c1/c1 end;
select c1, case c1 when 1 then c1 * c1 when 2 then 2.321 + c1 end between -1 and 10 as res from t;
select (CASE 'two' when 'one' then '1' WHEN 'two' then '2' END) | 0 as res;
select * from t where case when c1>=3 and c1%2 != 0 then true else false end;
select * from t where case when c1>=3 or c1<2 then true else false end;
select * from t where case when c1 is not null then true else false end;
select case c1 when 1 then c1 when 2 then 'yaobase' end || case c1 when 3 then c1+5 when 2 then 'YaoBase' end as res from t;
select 2.0 * (CASE 1 when 1 then 0.05+0.01 WHEN 2 then 2 END) -0.42 as res;
#集合运算
(SELECT 'case+union+test' from dual) UNION  (SELECT CASE '1' WHEN '2' THEN 'BUG' ELSE 'nobug' END from dual);
(select case c1 when 1 then c1+1 when 2 then c1+2 when 3 then 'c' end as res from t ) INTERSECT (select case c1 when 1 then c1+1 when 2 then c1+2 when 3 then 'c' end as res from t) ;
(select case c1 when 1 then c1+1 when 2 then c1+2 when 3 then 'c' end as res from t1 ) EXCEPT (select case c1 when 1 then c1*c1 when 2 then c1*c1*c1 when 3 then 'c' end as res from t1);
#边界
select CASE 1 when 1 then 9223372036854775807 WHEN 2 then '2' END as res;
select CASE 1 when 1 then -9223372036854775807-1  WHEN 2 then '2'  END as res;
#SQL不同位置
select case c1 when 1 then 'one' when 2 then 'two' else 'nothing' end as fcase, count(*) from t group by fcase;
SELECT ProductName,UnitPrice, CASE WHEN UnitPrice > 50 THEN 'Expensive' ELSE 'Affordable' END AS PriceCategory FROM Products ORDER BY UnitPrice DESC;
select t3.*,t4.c3 from t4 join t3 on t3.c2 = t4.c2 where case  when t3.c1 = 2 then t3.c3 in(3,6,8)  when t3.c1 = 3 then t4.c3 in(6,7,8) end;
create table t5(c1 int, c2 int, c3 int, c4 int, c5 int);
insert into t5 values(1,2,3,4,5), (1,3,2,5,4),(2,1,3,4,5);
select case when c1=1 then (case when c2=2 then (case when c3=3 then (case when c4= 4 then (case when c5=5 then '12345' end)end) end )end) end from t5;
select case when c2=1 then '1' when c2=2 then (case when c3=2 then '2' else '' end) when c2=3 then (case when c3=3 then '3' else '' end) else '' end as res from t5;

create table t6(c1 int, c2 int , c3 int, c4 int);
insert into t6 values (1,2,3,4), (1,2,4,5), (2,3,4,5),(2,3,5,6);
select 
  case when c1 = 1 then 
        (case when c2=2 then (case when c3=3 then (case when c4=4 then '1234' else '123-' end)
		when c3=4 then (case when c4=5 then '1245' else '124-' end) end) END)
	when c1 = 2 then 
		(case when c2=3 then (case when c3=4 then (case when c4=5 then '2345' else '123-' end) when c3=5 then (case when c4=6 then '2356' else '124-' end) end)
        END) end  as res from t6;
#函数测试
drop table t1;
create table t1 (`row` int not null, col int not null, val varchar(255) not null);
insert into t1 values (1,1,'orange'),(1,2,'large'),(2,1,'yellow'),(2,2,'medium'),(3,1,'green'),(3,2,'small');
select max(case col when 1 then val else null end) as color from t1 group by `row`;
drop table t1;
create table t1(a float, b int default 3);
insert into t1 (a) values (2), (11), (8);
select min(a), min(case when 1=1 then a else NULL end) as res, min(case when 1!=1 then NULL else a end) as res from t1 where b=3 group by b;
SELECT CASE UPPER('c') WHEN 'C' THEN 'nobug' ELSE 'BUG' END AS res;
SELECT CASE UPPER('c') WHEN 'C' THEN 'nobug' ELSE 'BUG' END AS res;
select CASE concat('a','b') when concat('ab','') then 'a' when 'b' then 'b' end;
select concat((CASE 1 when 1 then 1 WHEN 2 then '2' END),'') + 2 as reult ;

create table bt(c int, b bit(4));
insert into bt values(1,b'0101');
insert into bt values(2,b'0101');
select c,length(case c when 1 then 'b' when 2 then 'aa' end) from bt;
select c,case c when 1 then length('b') when 2 then length('aa') end as res from bt;

select (CASE 1 when 1 then 'abc' WHEN 2 then 'abcd' END) like '%ab_%' as res;
select c1, substr(case c1 when 1 then substr('YaoBase',3) when 2 then substr('YaoBase',3,2) when 3 then substr('YaoBase',-3) when 4 then substr('YaoBase',3,-2) end, 1) as res from t;
select c1, case c1 when 1 then TRIM(' MySQL TRIM Function ') when 2 then 2.321 end as res from t;
select c1, instr(case c1 when 1 then instr(TRIM(' MySQL TRIM Function '),'Function',1) when 2 then 2.321 end,'1',1) as res from t;
drop table if exists t1;

create table t1(c1 bigint primary key,c2 int,c3 float,c4 double,c5 decimal(10,5),c6 varchar(100),c7 bool);
insert into t1 values(12321112147483647,2,3.15,5.57,77777.97687,'12321321.123123',true),(-12321112147483647,-2,-3.15,-5.5656,-77777.77777,'-7878787.3569',false);
select left(case when c7 then 'yaobase' else 'YAOBASE' end,3) as res from t1;
select right(case when c7 then 'yaobase' else 'YAOBASE' end,2) as res from t1;
select c1, nvl2(case c1 when 1 then instr(TRIM(' MySQL TRIM Function '),'Function',1) when 2 then 2.321 end,'no','nobug') as res from t;
#聚合函数
create view debug as select CASE sum(1+4) when 5 then sum(1+6) when 6 then 'b' end as res; 
desc debug;
select * from debug;
SELECT categoryID,AVG( unitPrice ) AS AvgPrice,CASE WHEN AVG( unitPrice ) > 50 THEN 'High Price' ELSE 'Low Price'  END AS PriceCategory  FROM products GROUP BY categoryID;
SELECT categoryID,SUM( unitPrice ),COUNT(unitPrice),AVG( unitPrice ) AS AvgPrice,CASE WHEN SUM( unitPrice ) > 200 THEN 'High Price' ELSE 'Low Price' END AS PriceCategory FROM products GROUP BY categoryID;
SELECT ProductName,UnitPrice,StockQuantity,CASE WHEN StockQuantity > rank() OVER () THEN 'Above Avg Stock' ELSE 'Below Avg Stock' END AS StockComparison FROM Products;
select case when c2 > 0 then round(c3,1) when c3 > 0 then 'abc' else round(c3,1) end as res from t1;
select case when c2 > 0 then floor(c3) when c2<0 then  ceil(c3) else '0' end as res from t1;
select case when c3 > 0 then format(c3,1) when c3<0 then  format(c5,-2) else '0' end as res from t1;
create table timefunc(id int AUTO_INCREMENT,t timestamp, primary key(id));
insert into timefunc(t) values(current_timestamp()),(current_timestamp()),(current_timestamp()),(current_timestamp()),(current_timestamp()),(current_timestamp()),(current_timestamp()),(current_timestamp());
--replace_column 2 '2024-06-14 15:29:04.459980'
select * from timefunc;
create view timefuncT as select case id when 1 then year(t) when 2 then month(t) when 3 then day(t) when 4 then days(t) when 5 then hour(t) when 6 then minute(t) when 7 then second(t) end as res from timefunc;
#返回类型
DROP TABLE if exists adt;
CREATE TABLE adt(a int AUTO_INCREMENT,tint tinyint, it int, sint smallint, mint mediumint,bint Bigint, flo float, dou DOUBLE, deci decimal(3, 2),varc varchar(30),dt date, ti timestamp, js JSON,bt bit(4),PRIMARY KEY (a));
INSERT INTO adt(tint, it , sint, mint, bint, flo, dou, deci, varc, dt , ti , js , bt)
VALUES(126, 2147483647, 32767, 8388607, 9223372036854775807, 2.1, 23.15, 2.31, 'yaobase', '2024-02-24', '2024-02-24 17:19:05.017917', '{}', b'0101')
,(126, 2147483647, 32767, 8388607, 9223372036854775807, 2.1, 23.15, 2.31, 'yaobase', '2024-02-24', '2024-02-24 17:19:05.017917', '{}', b'0101')
,(126, 2147483647, 32767, 8388607, 9223372036854775807, 2.1, 23.15, 2.31, 'yaobase', '2024-02-24', '2024-02-24 17:19:05.017917', '{}', b'0101')
,(126, 2147483647, 32767, 8388607, 9223372036854775807, 2.1, 23.15, 2.31, 'yaobase', '2024-02-24', '2024-02-24 17:19:05.017917', '{}', b'0101')
,(126, 2147483647, 32767, 8388607, 9223372036854775807, 2.1, 23.15, 2.31, 'yaobase', '2024-02-24', '2024-02-24 17:19:05.017917', '{}', b'0101')
,(126, 2147483647, 32767, 8388607, 9223372036854775807, 2.1, 23.15, 2.31, 'yaobase', '2024-02-24', '2024-02-24 17:19:05.017917', '{}', b'0101')
,(126, 2147483647, 32767, 8388607, 9223372036854775807, 2.1, 23.15, 2.31, 'yaobase', '2024-02-24', '2024-02-24 17:19:05.017917', '{}', b'0101')
,(126, 2147483647, 32767, 8388607, 9223372036854775807, 2.1, 23.15, 2.31, 'yaobase', '2024-02-24', '2024-02-24 17:19:05.017917', '{}', b'0101')
,(126, 2147483647, 32767, 8388607, 9223372036854775807, 2.1, 23.15, 2.31, 'yaobase', '2024-02-24', '2024-02-24 17:19:05.017917', '{}', b'0101')
,(126, 2147483647, 32767, 8388607, 9223372036854775807, 2.1, 23.15, 2.31, 'yaobase', '2024-02-24', '2024-02-24 17:19:05.017917', '{}', b'0101')
,(126, 2147483647, 32767, 8388607, 9223372036854775807, 2.1, 23.15, 2.31, 'yaobase', '2024-02-24', '2024-02-24 17:19:05.017917', '{}', b'0101')
,(126, 2147483647, 32767, 8388607, 9223372036854775807, 2.1, 23.15, 2.31, 'yaobase', '2024-02-24', '2024-02-24 17:19:05.017917', '{}', b'0101')
,(126, 2147483647, 32767, 8388607, 9223372036854775807, 2.1, 23.15, 2.31, 'yaobase', '2024-02-24', '2024-02-24 17:19:05.017917', '{}', b'0101')
,(126, 2147483647, 32767, 8388607, 9223372036854775807, 2.1, 23.15, 2.31, 'yaobase', '2024-02-24', '2024-02-24 17:19:05.017917', '{}', b'0101');
create view v1 as select a,case a when 1 then tint when 2 then it  when 3 then mint when 4 then bint  when 5 then flo when 6 then dou  when 7 then varc when 8 then dt  when 9 then ti when 10 then js when 11 then bt end as res from adt;
desc v1;
select * from v1;
create view v2 as select case a when 1 then tint when 2 then it when 3 then sint when 4 then mint when 5 then bint end as res from adt;
desc v2;
select * from v2;
drop table t3;
create table t3 (c1 int);
insert into t3 values(1),(2),(3);
create view v3 as select case c1 when 1 then 1 when 2 then cast(2.2 as double) when 3 then 3 end as c1 from t3;
desc v3;
select c1 from v3;
create view v4 as select case c1 when 1 then 1 when 2 then cast(2.2 as decimal(2,1)) when 3 then 3 end as c1 from t3;
desc v4;
select c1 from v4;
create view v5 as select case c1 when 1 then 1 when 2 then cast(2.2 as decimal(2,1)) when 3 then cast(2.2 as double) end as c1 from t3;
desc v5;
select c1 from v5;
create view v6 as select case c1 when 1 then 'a' when 2 then 'aa' when 3 then 'aaa' end as c1 from t3;
desc v6;
select c1 from v6;
create view v7 as select case c1 when 1 then b'01011' when 2 then 'aaa' when 3 then b'01010101' end as c1 from t3;
desc v7;
select c1 from v7;
create view v8 as select case c1 when 1 then cast('{"1":"2"}' as json) when 2 then cast('{"1":"2"}' as json) when 3 then cast('{"1":"2"}' as json) end as c1 from t3;
desc v8;
select c1 from v8;
drop table if exists t1;
create table t1(c1 int,ti tinyint,b bit(2));
insert into t1 values(1,1,1),(2,2,2);
create view view1 as select case c1 when 1 then ti when 2 then b end  as res from t1;
desc view1;
select * from view1;
create view view2 as select a,case a when 1 then bt when 2 then 'aa' end from adt;
desc view2;
select * from view2;
create view view3 as select a,case a when 1 then dt when 2 then ti when 3 then CURRENT_TIME() end as res from adt limit 4;
select * from view3 where res is null;
create view view4 as select case a when 1 then dt when 2 then CURRENT_date() when 3 then CURRENT_date() end as res from adt limit 4;
desc view4;
select * from view4 where res is null;
create view view5 as select case a when 1 then CURRENT_time() when 2 then CURRENT_time() when 3 then CURRENT_time() end as res from adt limit 4;
desc view5 ;
select * from view5 where res is null;
create view view6 as select case a when 1 then CURRENT_timestamp() when 2 then CURRENT_timestamp() when 3 then CURRENT_timestamp() end as res from adt limit 4;
desc view6 ;
select * from view6 where res is null;
#prepare
drop table if exists t1;
create table t1(c1 int primary key,c2  int,c3 int);
insert into t1 values(1,1,1),(2,2,2),(3,3,3);
prepare stmt1 from select c1 , case when c1=1  then ? else ? end from t1 where c1 <?;
set @a='AAA',@b='BBB',@c=3;
execute stmt1 using @a,@b,@c;

create view test as select c1,case when c1=1 then 'AAA' when c1 = 2 then 'BBB' else 'CCC' end as c2 from t1;
select c1,c2 from test;
#子查询
SELECT productName, unitPrice, ( CASE WHEN unitPrice > ( SELECT AVG( unitPrice ) FROM products ) THEN 'Above Avg' ELSE 'Below Avg' END ) AS PriceComparison FROM products;
SELECT  productName, unitPrice, stockQuantity,
CASE  
	WHEN stockQuantity > 150 THEN  'High' 
	WHEN stockQuantity > 100 THEN  'Medium' ELSE 'Low' 
	END AS StockCategory,
CASE  
	WHEN stockQuantity > 100 THEN  stockQuantity * 1.1 ELSE stockQuantity * 1.05 
	END AS AdjustedStock 
FROM  products;
#字符集聚合测试
create table collt(id int,var1 varchar(10) charset utf8mb4, var2 varchar(10) charset gbk,var3 varchar(10) charset gb18030,var4 varchar(10) charset utf16, var5 varchar(10) charset utf8mb4,var6 varchar(10) charset latin1);
insert into collt values(1,'yaob','yaob','yaob','yaob','yaob','yaob'),(2,'yaob','yaob','yaob','yaob','yaob','yaob'),(3,'yaob','yaob','yaob','yaob','yaob','yaob'),(4,'yaob','yaob','yaob','yaob','yaob','yaob'),(5,'yaob','yaob','yaob','yaob','yaob','yaob'),(6,'yaob','yaob','yaob','yaob','yaob','yaob');
select case id when 1 then var1 when 2 then var2 when 3 then var3 when 4 then var4 when 5 then var5 when 6 then var6 else 123 end as res from collt;
select charset(case id when 1 then var1 when 2 then var2 when 3 then var3 when 4 then var4 when 5 then var5 when 6 then var6 else 123 end) as res from collt;
create view vi1 as select charset(case id when 1 then var1 when 2 then var2 when 3 then var3 when 4 then var4 when 5 then var5 when 6 then var6 else 123 end) as res from collt;
select * from vi1;
  
###2-2：ISSUE188 支持select for update对多行加锁
connect(conn1,$OBMYSQL_MS0,admin,admin,yao,$OBMYSQL_PORT);
connection conn1;
drop table IF EXISTS kv;
create table kv(k int, v int);
insert into kv values(1,1), (2,2), (3,3);
BEGIN;
select * from kv where k = 1 for update;

connect(conn2,$OBMYSQL_MS0,admin,admin,yao,$OBMYSQL_PORT);
connection conn2;
BEGIN;
--error 119
select * from kv where k = 1 for update;

connection conn1;
update kv set k = 4 where k = 1;
commit;

connection conn2;
select * from kv where v = 1 for update;
commit;

disconnect conn1;
disconnect conn2;

--echo non_primary_key_select_for_update_test
connect(conn1,$OBMYSQL_MS0,admin,admin,yao,$OBMYSQL_PORT);
connection conn1;
drop table IF EXISTS kv;
create table kv(k int, v int);
insert into kv values(1,1), (2,2), (3,3);
BEGIN;
select * from kv where v = 1 for update;

connect(conn2,$OBMYSQL_MS0,admin,admin,yao,$OBMYSQL_PORT);
connection conn2;
BEGIN;
--error 119
select * from kv where v = 1 for update;
connection conn1;
update kv set k = 4 where v = 1;
commit;
connection conn2;
select * from kv where v = 1 for update;
commit;
disconnect conn1;
disconnect conn2;

connect(conn3,$OBMYSQL_MS0,admin,admin,yao,$OBMYSQL_PORT);
connection conn3;
--echo subquery_for_update_test
drop table IF EXISTS t2;
create table t2(c1 int, c2 int);
insert into t2 values(1,3);
insert into t2 values(2,4);
#--error 7
SELECT v+1 FROM kv WHERE v = (select c1 from t2 where c2 = 1 for update) for update;

--echo single_table_for_update_test
drop table IF EXISTS t2;
drop table IF EXISTS t3;
create table t2(c1 int, c2 int);
create table t3(c1 int, c2 int);
insert into t2 values(1,3);
insert into t2 values(2,4);
insert into t3 values(1,5);
insert into t3 values(2,6);
--error 5012
select * from t2 join t3 on t2.c1 = t3.c1 for update;

###2-3：ISSUE192 Semijoin 当连接条件左右表是同一张表时导致sqlserver出现core dump
drop table if exists t1,t2,t3,t4;
show variables like '%query_optimizer%';
create table t3(c1 decimal (10,0), c2 decimal (10,0), c3 decimal (10,0), c4 varchar (10), primary key(c1,c2)) compress_method = 'none',replica_num=3;
create table t4(c1 decimal (10,0), c2 decimal (10,0), c3 decimal (10,0), c4 varchar (16), c5 varchar (192), primary key(c1,c2)) compress_method = 'none',replica_num=3;
create index t3_c3 on t3 (c3,c1,c2) storing (c4);
--echo “merge”
exec $LOCAL_DIR/tools/as_admin -r $RS0_IP -p $RS0_PORT major_freeze | tail -1;
--real_sleep 600 
exec $LOCAL_DIR/tools/as_admin -r $RS0_IP -p $RS0_PORT stat -o merge | tail -1;
select /*+JOIN(SIB)*/ t3.c4 from t4 inner join t3 on t3.c4=t3.c4 where t3.c3=10;

drop table if exists t1,t2;
create table t1(c1 int, c2 int);
create table t2(c1 int, c2 int);
insert into t1 values(1,2),(1,2);
insert into t2 values(1,2),(1,2);
select * from t1,t2 where t2.c1 = t2.c1;
select * from t1 inner join t2 on t2.c1 = t2.c1;

insert into t1 values(3,2);
select * from t1 left join t2 on t2.c1 = t2.c1;
select * from t1 right join t2 on t2.c1 = t2.c1;
select /*+JOIN(SI)*/ t1.c2 from t1 inner join t2 on t2.c1 = t2.c1;
select /*+JOIN(SIB)*/ t1.c2 from t1 inner join t2 on t2.c1 = t2.c1;
select /*+JOIN(BLOOMFILTER_JOIN)*/ t1.c2 from t1 inner join t2 on t2.c1 = t2.c1;
select /*+JOIN(HASH_JOIN_SINGLE)*/ t1.c2 from t1 inner join t2 on t2.c1 = t2.c1;

drop table if exists t3;
create table t3(c1 int, c2 int);
insert into t3 values(1,2),(2,2);
select * from t1 inner join t2 on t2.c1 = t2.c1 inner join t3 on t3.c2 = t3.c2;
select * from t1 left join t2 on t2.c1 = t2.c1 inner join t3 on t3.c2 = t3.c2;
select * from t1 right join t2 on t2.c1 = t2.c1 inner join t3 on t3.c2 = t3.c2;

drop table if exists t1,t2;
create table t1(c1 int, c2 int);
create table t2(c1 int, c2 int);
insert into t1 values(1,2),(1,2);
insert into t2 values(1,2),(1,3);
select * from t1 inner join t2 on t2.c1 + 1 = t2.c1 + 1 and t2.c2 = 3;
select * from t1 inner join t2 on t2.c1 + 2 = t2.c1 + 3;
select /*+JOIN(SIB)*/ t1.c2 from t1 inner join t2 on t2.c1 + 1 = t2.c1 + 1;

###2-4：ISSUE198 Bugfix-develop-IssueList代码同步
#946 定义表别名同时group by或orderby后使用列别名时无法命中索引
drop table if exists t1;
create table t1(cl int primary key, c2 int, c3 int,c4 int);
create index idx1 on t1(c4);
--echo “merge”
exec $LOCAL_DIR/tools/as_admin -r $RS0_IP -p $RS0_PORT major_freeze | tail -1;
--real_sleep 600 
exec $LOCAL_DIR/tools/as_admin -r $RS0_IP -p $RS0_PORT stat -o merge | tail -1;
explain select c4 cc from t1 a order by cc;
explain select c4 cc from t1 a group by cc;
explain select c4 cc from t1 a order by c4;
explain select c4 cc from t1 a group by c4;

#963 修改原表列名，原表中列名修改成功，但索引表中该列名未修改（1.3.0.0已再现）
drop table if exists t1;
create table t1 (c1 int primary key,c2 varchar(8)) ;
create index idx_1 on t1(c2);
create unique index idx_2 on t1(c2);
show index on t1;
let $n=query_get_value(select table_id from __first_tablet_entry where table_name='t1',table_id,1);
--let $index_head =__
--let $index1_end =__idx__idx_1
--let $index1_name=$index_head$n$index1_end
echo $index1_name;
--let $index2_end =__idx__idx_2
--let $index2_name=$index_head$n$index2_end
echo $index2_name;
show index on t1;
--echo "merge"
exec $LOCAL_DIR/tools/as_admin -r $RS0_IP -p $RS0_PORT major_freeze | tail -1;
--real_sleep 500
exec $LOCAL_DIR/tools/as_admin -r $RS0_IP -p $RS0_PORT stat -o merge | tail -1;
desc t1;
#eval desc $index1_name;
#eval desc $index2_name;
alter table  t1 rename c2 to cc2;
desc t1;
#eval desc $index1_name;
#eval desc $index2_name;

#990 简化显示explain功能的表名、索引名
#用例B089_Explain中已体现：原始表现形式为【库名.表名】的形式，修改后不显示库名

#1003 kill -15 PID下线CB服务，会出现core dump文件
#使用1.1.1.0 1.3.0.0 版本未再现
#1.4.0.0版本，手动kill -15 ds服务的PID会出现core文件

#1004 查询__all_server_session导致ms宕机
--replace_column 1 '固定id' 3 '固定host' 6 '固定timeelapse' 9 '固定ss' 10 '固定index'
select * from __all_server_session;
--replace_column 1 '固定id' 3 '固定host' 6 '固定timeelapse' 9 '固定ss' 10 '固定index'
select * from __all_server_session limit 1;
--replace_column 1 '固定id' 3 '固定host' 6 '固定timeelapse' 9 '固定ss' 10 '固定index'
select * from __all_server_session where username='admin';

#1025 表有多张索引，开启查询优化，使用explain extended打印执行计划时POSSIBLE.KEYS列值不符预期
#目前查出的POSSIBLE.KEYS列一直为空，发生条件不明确
drop table if exists t1;
create table t1 (c1 int primary key,c2 varchar(8),c3 int,c4 int) ;
create index idx_1 on t1(c2);
create index idx_2 on t1(c2);
create index idx_3 on t1(c3);
create index idx_4 on t1(c4);
insert into t1 values(1,'aaa',1,1),(2,'bbb',2,2),(3,'ccc',3,3),(4,'ddd',4,4);
--echo “merge”
exec $LOCAL_DIR/tools/as_admin -r $RS0_IP -p $RS0_PORT major_freeze | tail -1;
--real_sleep 500 
exec $LOCAL_DIR/tools/as_admin -r $RS0_IP -p $RS0_PORT stat -o merge | tail -1;
explain extended select c2 from t1 where c2='aaa';

#1034 查询优化器打开，一个语句中同时出现left/right/full join与or column=常量时，ms下线
CREATE TABLE table_left (id INT,name VARCHAR(50));
CREATE TABLE table_right (id INT, age INT);
INSERT INTO table_left (id, name) VALUES(1, 'Alice'),(2, 'Bob'),(3, 'Charlie');
INSERT INTO table_right (id, age) VALUES(1, 25),(3, 30),(4, 35);
#1.3.0.0再现
SELECT * FROM table_left FULL JOIN table_right ON table_left.id = table_right.id OR table_right.age = 35;
SELECT * FROM table_left LEFT JOIN table_right ON table_left.id = table_right.id OR table_right.age = 35;
SELECT * FROM table_left RIGHT JOIN table_right ON table_left.id = table_right.id OR table_right.age = 35;

#1047 case when表达式else分支内bool类型输出有误
drop table if exists employees;
CREATE TABLE employees (employee_id INT PRIMARY KEY, first_name VARCHAR(50), last_name VARCHAR(50), is_manager BOOL);
INSERT INTO employees (employee_id, first_name, last_name, is_manager) VALUES(1, 'John', 'Doe', 1),(2, 'Jane', 'Smith', 0),(3, 'Emily', 'Davis', 0),(4, 'Michael', 'Johnson', 1),(5, 'Sarah', 'Wilson', 0);
SELECT
    employee_id,
    first_name,
    last_name,
    CASE 
        WHEN is_manager THEN 'Manager'
        ELSE is_manager 
    END as c1
FROM employees;

###///新添测试项///###
###2-x:(新增测试项说明)
#do sql
########################################################################################################
