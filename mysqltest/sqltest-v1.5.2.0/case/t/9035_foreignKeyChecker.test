--disable_query_log
set sql_quote_show_create=0;
--enable_query_log
##############################################################################################
###1.测试功能点：测试外键约束
#                         
#                 
#
###2.测试项：(每新添一测试项，需在添加前注明测试项，注释填写在新添sq1前，不填在此处，如下样例）
###3.问题网址：
###4.问题号：
###5.预计运行时间：
###6.编写/修改人：
###7.编写/修改日期：
###8.其他（选填）：case格式规范化修改
###
##
#
##############################################################################################

#####################################Do sql###################################################
###2-1:外键约束
##create table场景
create table t1(c1 int, c2 varchar(20), c3 double, primary key(c1, c2));
create table tt1(c1 int primary key, c2 int, c3 varchar(20), constraint cst foreign key(c2, c3) references t1(c1,c2));
create table tt2(c1 int primary key, c2 int, c3 varchar(20), foreign key(c2, c3) references t1(c1,c2));
--error 16
create table tt3(c1 int primary key, c2 int, c3 varchar(20), foreign key(c2, c3) references t1(c1));
#--error 16
create table tt3(c1 int primary key, c2 int, c3 varchar(2), foreign key(c2, c3) references t1(c1,c2));
drop table tt3;
--error 16
create table tt3(c1 int primary key, c2 int, c3 int, foreign key(c2, c3) references t1(c1,c2));
--error 5008
create table tt3(c1 int primary key, c2 int, c3 varchar(20), constraint cst foreign key(c2, c3) references t1(c1,c2), constraint cst foreign key(c2, c3) references t1(c1,c2));
create table tt3(c1 int primary key, c2 int, c3 varchar(20), constraint cst foreign key(c2, c3) references t1(c1,c2), constraint cst1 foreign key(c2, c3) references t1(c1,c2));
--error 16
create table tt4(c1 int primary key, c2 int, c3 varchar(20), foreign key(c2, c3) references t1(c1,c8));
create table tt4(c1 int primary key, c2 int, c3 varchar(25), foreign key(c2, c3) references t1(c1,c2));
show create table tt1;
#show create table tt2;
drop table tt1,tt2,tt3,tt4;
drop table t1;

create table t1(c1 int, c2 decimal(5,2), c3 double, primary key(c1, c2));
create table tt1(c1 int primary key, c2 int, c3 decimal(6,3), foreign key(c2, c3) references t1(c1,c2));
create table tt2(c1 int primary key, c2 int, c3 decimal(4,1), foreign key(c2, c3) references t1(c1,c2));
drop table tt1,tt2;
drop table t1;
--error 18
create table tt1(c1 int primary key, c2 int, c3 varchar(20), foreign key(c2, c3) references t1(c1,c2));
create table tt1(c1 int primary key, c2 int, constraint cst foreign key(c2) references tt1(c1));
drop table tt1;

##alter table场景
create table tt1(c1 int primary key, c2 int, constraint cst foreign key(c2) references tt1(c1));
--error 16
alter table tt1 drop foreign key cst1;
alter table tt1 drop foreign key cst;
drop table tt1;

create table tt1(c1 int primary key, c2 int);
alter table tt1 add constraint cst foreign key(c2) references tt1(c1);
drop table tt1;
create table tt1(c1 int primary key, c2 int);
insert into tt1 values(1,1);
--error 16
alter table tt1 add constraint cst foreign key(c2) references tt1(c1);
drop table tt1;

##drop table场景
create table t1(c1 int, c2 varchar(20), c3 double, primary key(c1, c2));
create table tt1(c1 int primary key, c2 int, c3 varchar(20), constraint cst foreign key(c2, c3) references t1(c1,c2));
--error 5002
alter table tt1 drop column c2;
--error 5002
alter table t1 drop column c2;
drop table tt1;
drop table t1;

##truncate table场景
create table t1(c1 int, c2 varchar(20), c3 double, primary key(c1, c2));
create table tt1(c1 int primary key, c2 int, c3 varchar(20), constraint cst foreign key(c2, c3) references t1(c1,c2));
create table tt2(c1 int primary key, c2 int, constraint cst foreign key(c2) references tt2(c1));
--error 16
truncate table t1;
truncate table tt1;
truncate table tt2;
drop table tt1,tt2;
drop table t1;

##insert场景
create table t1(c1 int, c2 varchar(20), c3 double, primary key(c1, c2));
create table tt1(c1 int primary key, c2 int, c3 varchar(20), constraint cst foreign key(c2, c3) references t1(c1,c2));
create table tt2(c1 int primary key, c2 int, constraint cst foreign key(c2) references tt2(c1));
insert into tt2 values(1,1);
insert into t1 values(1,'1',1);
insert into tt1 values(1,1,'1');
delete from tt1;
delete from t1;
delete from tt2;
insert into tt2 values(2,1),(1,2);
insert into t1 values(1,'1',1);
--error 5209
insert into tt1 values(1,1,'a');
delete from tt1;
delete from t1;
set foreign_key_checks=0;
insert into t1 values(1,'1',1);
insert into tt1 values(1,1,'a');
set foreign_key_checks=1;
delete from tt1;
delete from t1;

##replace场景
replace into t1 values(1,'1',1);
replace into tt1 values(1,1,'1');
delete from tt1;
delete from t1;
replace into t1 values(1,'1',1);
--error 5209
replace into tt1 values(1,1,'a');
delete from tt1;
delete from t1;
set foreign_key_checks=0;
replace into t1 values(1,'1',1);
replace into tt1 values(1,1,'a');
set foreign_key_checks=1;

##delete场景
delete from tt1;
delete from t1;
insert into t1 values(1,'1',1),(2,'2',2);
delete from t1;
select * from t1;
delete from tt1;
delete from t1;
insert into t1 values(1,'1',1),(2,'2',2);
insert into tt1 values(1,1,'1');
--error 119
delete from t1;

delete from tt1;
delete from t1;
insert into t1 values(1,'1',1),(2,'2',2);
insert into tt1 values(1,1,'1');
set foreign_key_checks=0;
delete from t1;
set foreign_key_checks=1;

delete from tt1;
delete from t1;
insert into t1 values(1,'1',1);
insert into tt1 values(1,1,'1'),(2,1,'1'),(3,1,'1');
delete from tt1 where c1=1;
select * from tt1;
delete from tt1;

##update场景
delete from t1;
insert into t1 values(1,'1',1),(2,'1',1);
update t1 set c2=2 where c2='1';
select * from t1;
delete from tt1;
delete from t1;
insert into t1 values(1,'1',1),(2,'2',2);
insert into tt1 values(1,1,'1');
--error 119
update t1 set c1=3;

delete from tt1;
delete from t1;
insert into t1 values(1,'1',1),(2,'2',2);
insert into tt1 values(1,1,'1');
set foreign_key_checks=0;
update t1 set c1=3;
set foreign_key_checks=1;

delete from tt1;
delete from t1;
insert into t1 values(1,'1',1),(3,'1',1);
insert into tt1 values(1,1,'1'),(2,1,'1');
update tt1 set c2=3;
select * from t1;

delete from tt1;
delete from t1;
insert into t1 values(1,'1',1);
insert into tt1 values(1,1,'1');
set foreign_key_checks=0;
update tt1 set c2=3 where c1=1;
set foreign_key_checks=1;
#自我引用的表批量update
replace into tt2 values(1,1),(2,1),(3,1);
update tt2 set c1=c1+1 where c1>1;
select * from tt2;
drop table tt1,tt2;
drop table t1;

##测试cascade和restrict指令下的增删改查场景
create table t1(c1 int, c2 varchar(20), c3 double, primary key(c1, c2));
create table tt1(c1 int primary key, c2 int, c3 varchar(20), constraint cst foreign key(c2, c3) references t1(c1,c2) on update cascade on delete cascade);
insert into t1 values(1,'1',1);
insert into tt1 values(1,1,'1');
delete from tt1;
delete from t1;
replace into t1 values(1,'1',1);
replace into tt1 values(1,1,'1');
delete from tt1;
delete from t1;
insert into t1 values(1,'1',1);
insert into tt1 values(1,1,'1');
delete from t1 where c1=1 and c2='1';
select * from tt1;
select * from t1;
delete from tt1;
delete from t1;
insert into t1 values(1,'1',1);
insert into tt1 values(1,1,'1');
update t1 set c1=3 where c1=1 and c2='1';
select * from tt1;
select * from t1;
#自我引用的表
create table tt2(c1 int primary key, c2 int, constraint cst foreign key(c2) references tt2(c1) on update cascade on delete cascade);
insert into tt2 values(1,1);
delete from tt2;
replace into tt2 values(2,1),(1,2),(3,3);
delete from tt2 where c1=3;
select * from tt2;
delete from tt2;
replace into tt2 values(2,1),(1,1);
update tt2 set c2=c2+1;
select * from tt2;
drop table tt1,tt2;
drop table t1;
#指定一个的操作限制
CREATE TABLE Categories (id INT PRIMARY KEY, name VARCHAR(50));
CREATE TABLE Products (id INT PRIMARY KEY,category_id INT,name VARCHAR(50),FOREIGN KEY (category_id) REFERENCES Categories(id) ON DELETE CASCADE);
INSERT INTO Categories (id, name) VALUES (1, 'Electronics');
INSERT INTO Products (id, category_id, name) VALUES (1, 1, 'Laptop');
DELETE FROM Categories WHERE id = 1;
select * from Categories;
select * from Products;
drop table Products,Categories;
CREATE TABLE Authors (id INT PRIMARY KEY, name VARCHAR(50));
CREATE TABLE Books (id INT PRIMARY KEY,author_id INT,title VARCHAR(50),FOREIGN KEY (author_id) REFERENCES Authors(id) ON DELETE RESTRICT);
INSERT INTO Authors (id, name) VALUES (1, 'Jane Doe');
INSERT INTO Books (id, author_id, title) VALUES (1, 1, 'Book 1');
--error 5209
DELETE FROM Authors WHERE id = 1;
select * from Authors;
select * from Books;
--error 119
update Authors set id =9 where id =1;
select * from Authors;
select * from Books;
drop table Books,Authors;
#交叉使用
CREATE TABLE Customers (id INT PRIMARY KEY, name VARCHAR(50));
CREATE TABLE Orders (id INT PRIMARY KEY, customer_id INT,order_date DATE, FOREIGN KEY (customer_id) REFERENCES Customers(id) ON UPDATE CASCADE ON DELETE RESTRICT);
INSERT INTO Customers (id, name) VALUES (1, 'John');
INSERT INTO Orders (id, customer_id, order_date) VALUES (1, 1, '2023-01-01');
UPDATE Customers SET name = 'John Smith' WHERE id = 1;
--error 5209
DELETE FROM Customers WHERE id = 1;
select * from Customers;
select * from Orders;
drop table Orders,Customers;

##结合唯一索引的测试场景
drop table if exists t1;
drop table if exists tt1;
create table tt1(c1 int not null, c2 varchar(20) not null, c3 double primary key, unique(c1, c2));
create table t1(c1 int primary key, c2 int, c3 varchar(20), constraint cst foreign key(c2, c3) references tt1(c1,c2));
insert into tt1 values(1,'1',1);
insert into t1 values(1,1,'1');
delete from t1;
delete from tt1;
set foreign_key_checks=0;
insert into tt1 values(1,'1',1);
insert into t1 values(1,1,'a');
select * from t1;
set foreign_key_checks=1;

delete from t1;
delete from tt1;
insert into tt1 values(1,'1',1);
insert into t1 values(1,1,'1');
--error 119
delete from tt1 where c1=1 and c2='1';
select * from tt1;

delete from t1;
delete from tt1;
insert into tt1 values(1,'1',1),(2,'1',2);
update tt1 set c2=2 where c2='1';
select * from tt1;
drop table tt1;
drop table t1;

#自身引用的表
create table tt2(c1 int not null unique, c2 int, c3 int primary key,constraint cst foreign key(c2) references tt2(c1));
insert into tt2 values(2,1,1),(1,2,2),(3,3,3),(4,4,4),(5,4,5);
delete from tt2;
insert into tt2 values(2,1,1),(1,1,2);
update tt2 set c2=c2+1 ;
select * from tt2;
drop table tt2;

##RENAME 场景
CREATE TABLE t1 (pk INT PRIMARY KEY);
CREATE TABLE T2 (fk INT);
ALTER TABLE T2 ADD FOREIGN KEY (fk) REFERENCES t1 (pk);
RENAME TABLE T2 TO T3;
DROP TABLE T3, t1;

##其它特殊场景
#有无数据下添加外键
CREATE TABLE table1 (id INT PRIMARY KEY, name VARCHAR(50));
CREATE TABLE table2 (id INT PRIMARY KEY, table1_id INT);
ALTER TABLE table2 ADD  constraint test1 FOREIGN KEY (table1_id) REFERENCES table1 (id);
--replace_column 1 '2023-12-01 14:17:12.949889' 2 '2023-12-01 14:17:12.949889'
select * from __all_foreign_key;
alter table table2 drop foreign key test1;
insert into table1 values(1,'aaa'),(2,'bbb');
insert into table2 values(1,11),(2,22);
--error 16
ALTER TABLE table2 ADD  constraint test2 FOREIGN KEY (table1_id) REFERENCES table1 (id);
select * from __all_foreign_key;
drop table table2,table1;
#无外键下设置foreign_key_checks=1
create table t1(c1 int, c2 varchar(20), c3 double, primary key(c1, c2));
create table tt1(c1 int primary key, c2 int, c3 varchar(20));
insert into t1 values(1,'1',1);
#有外键约束下报错error 5209
insert into tt1 values(1,1,'a');
drop table tt1,t1;
#指定的唯一索引列为NULL
#--error 166
CREATE TABLE table1 (id INT PRIMARY KEY, code VARCHAR(50), name VARCHAR(50), unique index idx_1(code));
drop table table1;
CREATE TABLE table1 (id INT PRIMARY KEY, code VARCHAR(50) not null, name VARCHAR(50) not null, unique index idx_1(code) storing(name));
CREATE TABLE table2 (id INT PRIMARY KEY,table1_code VARCHAR(50),FOREIGN KEY (table1_code) REFERENCES table1 (code));
drop table table2,table1;
#多张表指定了同一个表的某列为外键
CREATE TABLE table1 (id INT PRIMARY KEY, name VARCHAR(50));
CREATE TABLE table2 (id INT PRIMARY KEY,table1_id INT, FOREIGN KEY (table1_id) REFERENCES table1 (id));
CREATE TABLE table3 (id INT PRIMARY KEY,table1_id INT, FOREIGN KEY (table1_id) REFERENCES table1 (id));
SELECT * FROM table1 INNER JOIN table2 ON table1.id = table2.table1_id;
SELECT * FROM table1 INNER JOIN table3 ON table1.id = table3.table1_id;
INSERT INTO table1 (id, name) VALUES (1, 'Table1 Row');
INSERT INTO table2 (id, table1_id) VALUES (1, 1);
INSERT INTO table3 (id, table1_id) VALUES (1, 1);
--error 5209
DELETE FROM table1 WHERE id = 1;
select * from table1;
select * from table2;
select * from table3;
drop table table3,table2,table1;
#外键与权限的组合
CREATE TABLE table1 ( id INT PRIMARY KEY, name VARCHAR(50));
CREATE TABLE table2 ( id INT PRIMARY KEY, table1_id INT, FOREIGN KEY (table1_id) REFERENCES table1 (id));
CREATE USER 'user' IDENTIFIED BY 'test@123';
GRANT SELECT, INSERT ON test.table2 TO 'user';
connect (conn1,$OBMYSQL_MS0,admin,admin,test,$OBMYSQL_PORT);
connect (conn2,$OBMYSQL_MS0,user,test@123,test,$OBMYSQL_PORT);
connection conn2;
SELECT * FROM table2;
--error 5036
INSERT INTO table1 (id,name) VALUES (1, 'aa');
--error 5036
INSERT INTO table2 (id, table1_id) VALUES (1, 1);
connection conn1;
GRANT SELECT, INSERT ON test.table1 TO 'user';
connection conn2;
--error 5209
INSERT INTO table2 (id, table1_id) VALUES (1, 1);
--error 5036
update table2 set table1_id = 2;
connection conn1;
drop table table2,table1;
#外键与视图的结合
CREATE TABLE customers (customer_id INT PRIMARY KEY,customer_name VARCHAR(50));
CREATE TABLE orders (order_id INT PRIMARY KEY,customer_id INT, order_date DATE, FOREIGN KEY (customer_id) REFERENCES customers (customer_id));
INSERT INTO customers (customer_id, customer_name) VALUES (1, 'John');
INSERT INTO orders (order_id, customer_id, order_date) VALUES (1, 1, '2021-01-01');
INSERT INTO orders (order_id, customer_id, order_date) VALUES (2, 1, '2021-02-01');
CREATE VIEW v AS
SELECT orders.order_id, customers.customer_name, orders.order_date FROM orders INNER JOIN customers ON orders.customer_id = customers.customer_id;
SELECT * FROM v;
drop view v;
drop table customers,orders;
#外键与自增列组合
CREATE TABLE table1 (id INT PRIMARY KEY AUTO_INCREMENT,name VARCHAR(50));
CREATE TABLE table2 (id INT PRIMARY KEY AUTO_INCREMENT, table1_id INT, FOREIGN KEY (table1_id) REFERENCES table1 (id));
INSERT INTO table1 (name) VALUES ('Row 1');
INSERT INTO table2 (table1_id) VALUES (1);
select * from table2;
drop table table2,table1;

###///新添测试项///###
###2-x:(新增测试项说明)
#do sql
########################################################################################################
