####################################必填######################################################
####1.测试功能点：触发器参考mysql基础case
####
####2.测试项：(每新添一测试项，需在添加前注明测试项，注释填写在新添sq1前，不填在此处，如下样例）
####3.问题网址：xxx
####4.问题号：xxx
####5.预计运行时间：30.834836 s
####6.编写/修改人：yangf
####7.编写/修改日期：2025-01-23
####8.其他（选填）：新编case
####
###
##
###############################################################################################
--source merge.sql
######################################Do sql###################################################

#1-1  let us test some very simple trigger
drop table if exists t1;
create table t1 (i int);
create trigger trg before insert on t1 for each row set @a:=1;
set @a:=0;
select @a;
insert into t1 values (1);
select @a;
drop trigger if exists trg;

#1-2 let us test simple trigger reading some values 
drop table  if exists t1;
create table t1 (i int);
create trigger trg before insert on t1 for each row set @a:=new.i;
insert into t1 values (123);
select @a;
drop trigger if exists trg;

drop table t1;


#1-3 Let us test before insert trigger  --报错
# Such triggers can be used for setting complex default values
drop table  if exists t1;
create table t1 (i int not null, j int);
delimiter |;
create trigger trg before insert on t1 for each row 
begin 
  if new.j is NULL then
    set new.j:= new.i * 10;
  end if;
end|
insert into t1 (i) values (1)|
insert into t1 (i,j) values (2, 3)|
select * from t1|
drop trigger if exists trg|
drop table if exists t1|
delimiter ;|


#1-4 After insert trigger   
# Useful for aggregating data
drop table  if exists t1;
create table t1 (i int not null primary key);
create trigger trg after insert on t1 for each row 
  set @a:= if(@a,concat(@a, ':', new.i), new.i);
set @a:='';
insert into t1 values (2),(3),(4),(5);
select @a;
drop trigger if exists trg;

#1-5 Before update trigger --报错
# (In future we will achieve this via proper error handling in triggers)
drop table  if exists t1;
create table t1 (aid int not null primary key, balance int not null default 0);
insert into t1 values (1, 1000), (2,3000);
delimiter |;
create trigger trg before update on t1 for each row 
begin
  declare loc_err varchar(255);
  if abs(new.balance - old.balance) > 1000 then
    set new.balance:= old.balance;
    set loc_err := concat('Too big change for aid = ', new.aid);
    set @update_failed:= if(@update_failed, concat(@a, ':', loc_err), loc_err);
  end if;
end|
delimiter ;|
set @update_failed:='';
update t1 set balance=1500;
select @update_failed;
select * from t1;
drop trigger if exists trg;

#1-6 After update trigger
drop table  if exists t1;
create table t1 (i int);
insert into t1 values (1),(2),(3),(4);
create trigger trg after update on t1 for each row
  set @total_change:=@total_change + new.i - old.i;
set @total_change:=0;
update t1 set i=3;
select @total_change;
drop trigger if exists trg;


#1-7 Before delete trigger
# This can be used for aggregation too :)
drop table  if exists t1;
create table t1 (i int);
insert into t1 values (1),(2),(3),(4);
create trigger trg before delete on t1 for each row 
  set @del_sum:= @del_sum + old.i;
set @del_sum:= 0;
delete from t1 where i <= 3;
select @del_sum;
drop trigger if exists trg;


#1-8 After delete trigger. 
# Just run out of imagination.
drop table  if exists t1;
create table t1 (i int);
insert into t1 values (1),(2),(3),(4);
create trigger trg after delete on t1 for each row set @del:= 1;
set @del:= 0;
delete from t1 where i <> 0;
select @del;
drop trigger if exists trg;


#1-9  Several triggers on one table  --删除报错
drop table  if exists t1;
create table t1 (i int, j int);
delimiter |;
create trigger trg1 before insert on t1 for each row 
begin
  if new.j > 10 then
    set new.j := 10;
  end if;
end|

create trigger trg2 before update on t1 for each row 
begin
  if old.i % 2 = 0 then
    set new.j := -1;
  end if;
end|

create trigger trg3 after update on t1 for each row 
begin
  if new.j = -1 then
    set @fired:= 'Yes';
  end if;
end|

delimiter ;|
set @fired:='';
insert into t1 values (1,2),(2,3),(3,14);
select @fired;
select * from t1;
update t1 set j= 20;
select @fired;
select * from t1;
drop trigger if exists trg1;
drop trigger if exists trg2;
drop trigger if exists trg3;



#1-10 Let us test triggers which access other tables.
# Trivial trigger which inserts data into another table
drop table if exists t1, t2, t3;
create table t1 (id int primary key, data varchar(10), fk int);
create table t2 (event varchar(100));
create table t3 (id int primary key);
create trigger t1_ai after insert on t1 for each row
  insert into t2 values (concat('INSERT INTO t1 id=', new.id, ' data=', new.data, ';'));
insert into t1 (id, data) values (1, 'one'), (2, 'two');
select * from t1;
select * from t2;
drop trigger if exists t1_ai;

#1-11 Trigger which uses couple of tables (and partially emulates FK constraint)
drop table if exists t1, t2, t3;
create table t1 (id int primary key, data varchar(10), fk int);
create table t2 (event varchar(100));
create table t3 (id int primary key);
delimiter |;
create trigger t1_bi before insert on t1 for each row
begin
  if exists (select id from t3 where id=new.fk) then
    insert into t2 values (concat('INSERT INTO t1 id=', new.id, ' data=', new.data, ' fk=', new.fk));
  else
    insert into t2 values (concat('INSERT INTO t1 FAILED id=', new.id, ' data=', new.data,  ' fk=' , new.fk));
    set new.id= 100;
  end if;
end|
delimiter ;|
insert into t3 values (1);
insert into t1 values (4, 'four', 1), (5, 'five', 2);
select * from t1;
select * from t2;
drop trigger if exists t1_bi;

#1-12 Trigger which invokes function 
drop table if exists t1, t2,t3;
create table t1 (id int primary key, data varchar(10));
create table t2 (seq int);
insert into t2 values (10);
delimiter |;
create function f1 () returns int return (select max(seq) from t2);|
create trigger t1_bi before insert on t1 for each row
begin
  if new.id > f1() then
    set new.id:= f1();
  end if;
end|
delimiter ;|
insert into t1 values (1, 'first');
insert into t1 values (f1(), 'max');
select * from t1;
drop function f1;


#1-13 Trigger which forces invocation of another trigger  --报错
# (emulation of FK on delete cascade policy)
drop table if exists t1, t2,t3;
create table t1 (id int primary key, fk_t2 int);
create table t2 (id int primary key, fk_t3 int);
create table t3 (id int primary key);
insert into t1 values (1,1), (2,1), (3,2);
insert into t2 values (1,1), (2,2);
insert into t3 values (1), (2);
create trigger t3_ad after delete on t3 for each row
  delete from t2 where fk_t3=old.id;

create trigger t2_ad after delete on t2 for each row
  delete from t1 where fk_t2=old.id;

delete from t3 where id = 1;
select * from t1 left join (t2 left join t3 on t2.fk_t3 = t3.id) on t1.fk_t2 = t2.id;


#1-14 Trigger which assigns value selected from table to field of row
# being inserted/updated.
drop table if exists t1, t2,t3;
create table t1 (id int primary key, copy int);
create table t2 (id int primary key, data int);
insert into t2 values (1,1), (2,2);
create trigger t1_bi before insert on t1 for each row
  set new.copy= (select data from t2 where id = new.id);

create trigger t1_bu before update on t1 for each row
  set new.copy= (select data from t2 where id = new.id);

insert into t1 values (1,3), (2,4), (3,3);
select * from t1;
update t1 set copy= 1 where id = 2;
select * from t1;
drop table t1, t2;

#1-15 Test of wrong column specifiers in triggers  --报错
drop table if exists t1, t2,t3;
drop trigger if exists trg;
create table t1 (i int);
create view v1 as select * from t1;
--error 7015
create trigger trg before insert on v1 for each row set @a:=1;
insert into t1 values(1);
select * from t1;
select * from v1;
drop view if exists v1;

#1-16 Test of wrong column specifiers in triggers  --报错
drop table if exists t1;
create table t1(i int,j int);
--error 7007
create trigger trg before insert on t1 for each row set @a:= old.i;

#1-17 New .FRM parser was not handling escaped strings properly.  --报错
drop table if exists t1;
create table t1 (x1col char);  
create trigger tx1 before insert on t1 for each row set new.x1col = 'x';
insert into t1 values ('y');
select * from t1;
drop trigger tx1;
drop table t1;


#1-18 If we are going to delete all rows in table but DELETE triggers exist  --报错
drop table if exists t1;
create table t1 (i int);
insert into t1 values (1), (2);
create trigger trg1 before delete on t1 for each row set @del_before:= @del_before + old.i;
create trigger trg2 after delete on t1 for each row set @del_after:= @del_after + old.i;
set @del_before:=0, @del_after:= 0;
delete from t1;
select @del_before, @del_after;
drop trigger trg1;
drop trigger trg2;
drop table t1;


#1-19 Test for bug  'Triggers are not activated for INSERT ... SELECT'.  --报错
# (We also check the fact that trigger modifies some field does not affect
#  value of next record inserted).
delimiter |;
create table t1 (i int, j int default 10)|
create table t2 (i int)|
insert into t2 values (1), (2)|
create trigger trg1 before insert on t1 for each row 
begin
  if new.i = 1 then
    set new.j := 1;
  end if;
end|
create trigger trg2 after insert on t1 for each row set @a:= 1|
set @a:= 0|
--error 7
insert into t1 (i) select * from t2|
select * from t1|
select @a|
# This also will drop triggers
drop table t1, t2|
delimiter ;|


# 1-20 Test for bug  'Triggers with dropped functions cause crashes'  --报错
# Appropriate error should be reported instead of crash.
create table t1 (col1 int, col2 int); 
insert into t1 values (1, 2);
delimiter |;
create function f1 () returns int return 5|
delimiter ;|
create trigger t1_bu before update on t1 for each row set new.col1= f1();
drop function f1; 
--error 119
update t1 set col2 = 4;
drop trigger t1_bu;
drop table t1;

#1-21Wrong index given to function in trigger  --报错
set yao_decimal_add_zero=true;
create table t1(i int not null, j int not null, n numeric(15,2), primary key(i,j));
create table t2(i int not null, n numeric(15,2), primary key(i));
delimiter |;
create trigger t1_ai after insert on t1 for each row
begin
  declare sn numeric(15,2);
  select sum(n) into sn from t1 where i=new.i;
  replace into t2 values(new.i, sn);
end|
delimiter ;|
insert into t1 values
  (1,1,10.00),(1,2,10.00),(1,3,10.00),(1,4,10.00),(1,5,10.00),
  (1,6,10.00),(1,7,10.00),(1,8,10.00),(1,9,10.00),(1,10,10.00),
  (1,11,10.00),(1,12,10.00),(1,13,10.00),(1,14,10.00),(1,15,10.00);
select * from t1;
select * from t2;
drop table t1, t2;
set yao_decimal_add_zero=false;


#1-22 Test for bug  'Multi-table UPDATE does not activate update triggers'
# We will also test how delete triggers wor for multi-table DELETE.
drop table if exists t1, t2;
create table t1 (i int, j int default 10, k int not null, key (k));
create table t2 (i int);
insert into t1 (i, k) values (1, 1);
insert into t2 values (1);
create trigger trg1 before update on t1 for each row set @a:= @a + new.j - old.j;
create trigger trg2 after update on t1 for each row set @b:= 'Fired';
set @a:= 0, @b:= '';
update t1 set j = j + 10 where t1.i =1;
select @a, @b;
insert into t1 values (2, 13, 2);
insert into t2 values (2);
set @a:= 0, @b:= '';
update t1 set j = j + 15 where t1.i = 1;
select @a, @b;
create trigger trg3 before delete on t1 for each row set @c:= @c + old.j;
create trigger trg4 before delete on t2 for each row set @d:= @d + old.i;
create trigger trg5 after delete on t1 for each row set @e:= 'After delete t1 fired';
create trigger trg6 after delete on t2 for each row set @f:= 'After delete t2 fired';
set @c:= 0, @d:= 0, @e:= '', @f:= '';
delete from t1 where t1.i = 1;
select @c, @d, @e, @f;
# This also will drop triggers
drop table t1, t2;


#1-23 procedure and trigger --报错
drop table  if exists t1;

create table t1 (c1 int, c2 datetime);
insert into t1 (c1) values (1),(2),(3);
select * from t1;
delimiter |;
create procedure f11(x char(16))
begin
  select 'hello';
  select 'hello again';
end|

create trigger tr1 before insert on t1 for each row 
begin 
  call f11(new.c2);
  set new.c2= '2004-04-02';
end|
delimiter ;|
--error 7
insert into t1 (c1) values (4),(5),(6);
select * from t1;

drop procedure f11;
drop table t1;

#1-24 Test of wrong column specifiers in triggers

create table t1(i int,j int);
--error 7007
create trigger trg before insert on t1 for each row set @a:= old.i;
--error 7007
create trigger trg before delete on t1 for each row set @a:= new.i;
--error 7009
create trigger trg before update on t1 for each row set old.i:=1;
--error 7007
create trigger trg before delete on t1 for each row set new.i:=1;
--error 7013
create trigger trg after update on t1 for each row set new.i:=1;
drop table t1;

#1-25 ddl triggers
create table t1 (i int not null, j int);
delimiter |;
create trigger  trg before insert on t1 for each row 
begin 
  if new.j is NULL then
    set new.j:= new.i * 10;
  end if;
end;|
delimiter ;|
insert into t1(i) values (1);
insert into t1(i,j) values (2, 3);
select * from t1;
--replace_column 6 '2025-1-23'
show triggers;
drop trigger trg;
show triggers;

#1-26 trigger order
CREATE TABLE t(c1 INT);
CREATE TABLE msg(c1 INT AUTO_INCREMENT PRIMARY KEY, c2 VARCHAR(100));
delimiter |;
CREATE TRIGGER IF NOT EXISTS trg1_t BEFORE INSERT ON t FOR EACH ROW
BEGIN
  INSERT INTO msg(c2) VALUES ('BEFORE INSERT trg1_t');
END;
|
CREATE TRIGGER trg2_t BEFORE INSERT ON t FOR EACH ROW FOLLOWS trg1_t
BEGIN
  INSERT INTO msg(c2) VALUES ('BEFORE INSERT trg2_t');
END;
|
CREATE TRIGGER trg3_t BEFORE INSERT ON t FOR EACH ROW FOLLOWS trg1_t
BEGIN
  INSERT INTO msg(c2) VALUES ('BEFORE INSERT trg3_t');
END;
|

CREATE TRIGGER trg4_t BEFORE INSERT ON t FOR EACH ROW PRECEDES trg1_t
BEGIN
  INSERT INTO msg(c2) VALUES ('BEFORE INSERT trg4_t');
END;
|
delimiter ;|
INSERT INTO t VALUES (1);
SELECT * FROM msg;
