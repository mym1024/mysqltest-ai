####################################必填######################################################
###1.测试功能点：在不指定分区规则下，读写bigint类型的数据
##
#
###2.测试项：(每新添一测试项，需在添加前注明测试项，注释填写在新添sq1前，不填在此处，如下样例）
###3.问题网址：xxx
###4.问题号：xxx
###5.预计运行时间：xxx
###6.编写/修改人：xxx
###7.编写/修改日期：xxx
###8.其他（选填）：xxx
###
##
#
##############################################################################################

#####################################Do sql###################################################
##
## Initialize
#
--disable_warnings
drop table if exists t1,t2;
--enable_warnings
#
##
## Test of reading of bigint values
##
#select 0,256,00000000000000065536,2147483647,-2147483648,2147483648,+4294967296;
#select 9223372036854775807,-009223372036854775808;
#select +9999999999999999999,-9999999999999999999;
#select cast(9223372036854775808 as unsigned)+1;
#select 9223372036854775808+1;
#select -(0-3),round(-(0-3)), round(9999999999999999999);
#select 1,11,101,1001,10001,100001,1000001,10000001,100000001,1000000001,10000000001,100000000001,1000000000001,10000000000001,100000000000001,1000000000000001,10000000000000001,100000000000000001,1000000000000000001,10000000000000000001;
#select -1,-11,-101,-1001,-10001,-100001,-1000001,-10000001,-100000001,-1000000001,-10000000001,-100000000001,-1000000000001,-10000000000001,-100000000000001,-1000000000000001,-10000000000000001,-100000000000000001,-1000000000000000001,-10000000000000000001;
#select conv(1,10,16),conv((1<<2)-1,10,16),conv((1<<10)-2,10,16),conv((1<<16)-3,10,16),conv((1<<25)-4,10,16),conv((1<<31)-5,10,16),conv((1<<36)-6,10,16),conv((1<<47)-7,10,16),conv((1<<48)-8,10,16),conv((1<<55)-9,10,16),conv((1<<56)-10,10,16),conv((1<<63)-11,10,16);
#
##
## In 3.23 we have to disable the test of column to bigint as 
## this fails on AIX powerpc (the resolution for double is not good enough)
## This will work on 4.0 as we then have internal handling of bigint variables.
##
#
###2-1：读写bigint类型数据
create table t1(pk bigint,a bigint,primary key(pk));
insert into t1 values(1,18446744073709551615),(2,18446744073709551613),(3,18446744073709551612);
select * from t1;
select * from t1 where a=18446744073709551615;
select * from t1 where a=18446744073709551613;
select * from t1 where a='18446744073709551615';
select * from t1;
drop table t1;
#
create table t1(a bigint primary key, big bigint);
insert into t1(a,big) values(1,-1),(2,12345678901234567),(3,9223372036854775807),(4,18446744073709551615);
select * from t1;
select min(big),max(big),max(big)-1 from t1;
select min(big),max(big),max(big)-1 from t1 group by a;
insert into t1(a,big) values(5,18446744073709551615);
select * from t1;
select min(big),max(big),max(big)-1 from t1;
select min(big),max(big),max(big)-1 from t1 group by a;
drop table t1;
#
##
## Test problem with big values for auto_increment
##
#
#create table t1 (id bigint auto_increment primary key, a bigint) auto_increment=9999999999;
#insert into t1 values (null,1);
#select * from t1;
#select * from t1 limit 9999999999
#drop table t1;
#
## Item_uint::save_to_field()
## BUG#1845
## This can't be fixed in mysql 4.0 without loosing precisions for bigints
##
#
CREATE TABLE t1(pk bigint primary key,f double);
insert into t1 values(1,10000000000000000000);
insert into t1 values(2,10000000000000000000.0);
insert into t1 values(3,'10000000000000000000');
select * from t1;
drop table t1;
#
## atof() behaviour is different of different systems. to be fixed in 4.1
#SELECT '0x8000000000000001'+0;
#
## Test for BUG#8562: joins 
create table t1(
 value64 bigint,
 value32 bigint,
 extra   bigint,
 primary key(value64,value32)
);
#
create table t2(
 value64 bigint,
 value32 bigint,
 extra   bigint,
 primary key(value64,value32)
);
#
insert into t1(value64,value32) values(17156792991891826145,1);
insert into t1(value64,value32) values( 9223372036854775807,2);
insert into t2(value64,value32) values(17156792991891826145,3);
insert into t2(value64,value32) values( 9223372036854775807,4);
#
select * from t1;
select * from t2;
#
#
#
#
drop table t1,t2;
#
##
##
#
create table t1(sint64 bigint primary key,a bigint);
insert into t1(sint64) values(-9223372036854775808);
select * from t1;
#
drop table t1;
#
####################
create table t1 (a char(100) primary key,b varchar(100),c varchar(256),d varchar(256));
insert into t1 values(
  18446744073709551615,18446744073709551615,
  18446744073709551615,18446744073709551615
);
select * from t1;
drop table t1;

create table t1(quantity double primary key,extra bigint);
insert into t1(quantity) values(500),(-500),(0),(-1);
select * from t1;
drop table t1;

#
## 注释部分没写
#


###///新添测试项///###
###2-x:(新增测试项说明)
#do sql
########################################################################################################
