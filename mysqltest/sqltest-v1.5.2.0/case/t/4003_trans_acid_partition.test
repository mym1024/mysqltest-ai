#######################################################
###1.测试功能点：在不同分区规则下，测试事务的ACID四大特性；
#######################################################


--disable_warnings
drop table if exists t1,t2,t3,t4;
--enable_warnings
--real_sleep 1


###2-1:在list分区规则下，发起多个会话窗口执行事务
# update within trx
create table t1 (pk int primary key, a int) partition by list(pk)(partition a1 values in(1,3), partition a2 values in (2,4));
--real_sleep 1
insert into t1 values(1,1);
--real_sleep 1
insert into t1 values(2,1);
--real_sleep 1
insert into t1 values(3,1),(4,1);
--real_sleep 1

connect(conn1,$OBMYSQL_MS0,admin,admin,test,$OBMYSQL_PORT);
connect(conn2,$OBMYSQL_MS0,admin,admin,test,$OBMYSQL_PORT);
connect(conn3,$OBMYSQL_MS0,admin,admin,test,$OBMYSQL_PORT);
connect(conn4,$OBMYSQL_MS0,admin,admin,test,$OBMYSQL_PORT);

# CASE1: conn1
--echo -- conn1 update row1 to +1
connection conn1;
begin;
update t1 set a=a+1 where pk=1;
--real_sleep 1
replace into t1 values(3,3),(4,4);
--real_sleep 1

--echo -- conn2 update row2 to +1, then update row1 to +1
connection conn2;
begin;
update t1 set a=a+1 where pk=2;
--error 5049
delete from t1 where pk=4;
--real_sleep 1
--error 5049
update t1 set a=a+1 where pk=1;
--real_sleep 1
ROLLBACK;

connection conn1;
commit;
--real_sleep 1
select * from t1;

drop table t1;
--real_sleep 1

--echo ###################


###2-2:在enum分区规则下，发起多个会话窗口执行事务
create enum partition function e1(x)'[(1)],[(2)],[(3)],[(4)],[(5)],[(6)]';
--real_sleep 1
create table t1 (pk varchar(30) primary key, a varchar(30)) partition by (ta1,e1,pk);
--real_sleep 1
insert into t1 values('1','1');
--real_sleep 1
insert into t1 values('2','1');
--real_sleep 1
insert into t1 values('3','1'),('4','1');
--real_sleep 1

# CASE1: conn1
--echo -- conn1 update row1 to '2'
connection conn1;
begin;
update t1 set a='2' where pk='1';
replace into t1 values('5','1'),('4','4');
--real_sleep 1
--echo -- conn2 update row2 to '2', then update row1 to '3'
connection conn2;
begin;
update t1 set a='2' where pk='2';
delete from t1 where pk=3;
--real_sleep 1
--error 5049
update t1 set a='3' where pk='1';
ROLLBACK;

connection conn1;
commit;
--real_sleep 1

select * from t1;

drop table t1;
drop partition function e1;

--real_sleep 1
--echo ###################

###2-3:在range分区规则下，发起多个会话窗口执行事务
create table t1 (pk int primary key, inta1 int, inta2 int, inta3 int, inta4 int) partition by range(pk)(partition d1 values less than(3),partition d2 values less than(6),partition d3 values less than maxvalue);
--real_sleep 10
insert into t1 values(1,1,1,-1,-1);
--real_sleep 1
insert into t1 values(2,2,2,-2,-2);
--real_sleep 1
insert into t1 values(3,3,3,-3,-3);
--real_sleep 1
insert into t1 values(4,4,4,-4,-4);
--real_sleep 1
insert into t1 values(5,5,5,-5,-5);
--real_sleep 1
commit;
--real_sleep 1
select sum(inta1+inta2+inta3+inta4) as mysum from t1;

connection conn1;

begin;
update t1 set inta1=inta1+1 where pk=1;
--real_sleep 1
update t1 set inta3=inta3-1 where pk=3;
--real_sleep 1
update t1 set inta3=inta3-1 where pk=1;
--real_sleep 1
update t1 set inta1=inta1+1 where pk=3;
--real_sleep 1
commit;
--real_sleep 1
connection conn2;
begin;
update t1 set inta1=inta1+1 where pk=2;
--real_sleep 1
update t1 set inta1=inta1+1 where pk=4;
--real_sleep 1
update t1 set inta3=inta3-1 where pk=4;
--real_sleep 1
update t1 set inta3=inta3-1 where pk=2;
--real_sleep 1

connection conn3;
begin;
update t1 set inta1=inta1+1 where pk=5;
--real_sleep 1
update t1 set inta3=inta3-1 where pk=5;
--real_sleep 1
update t1 set inta3=inta3-1 where pk=1;
--real_sleep 1
update t1 set inta1=inta1+1 where pk=1;
--real_sleep 1

connection conn4;
begin;
update t1 set inta3=inta3-1 where pk=3;
--real_sleep 1
update t1 set inta1=inta1+1 where pk=3;
--real_sleep 1
--error 5049
update t1 set inta1=inta1+1 where pk=2;
--real_sleep 1
--error 5049
update t1 set inta3=inta3-1 where pk=2;
--real_sleep 1
ROLLBACK;

connection conn2;
commit;
--real_sleep 1
connection conn3;
commit;
sleep 10;
select * from t1;

drop table t1;
--real_sleep 1

--echo ###################

###2-4:在hash分区规则下，发起多个会话窗口执行事务
create hash partition function h2(x,y)'x+y-2';
create table t1 (f1 int, f2 int,a int, primary key(f1,f2)) partition by (ta3,h2,f1,f2);
--real_sleep 1
insert into t1 values(1,1,1);
--real_sleep 1
insert into t1 values(1,2,1);
--real_sleep 1
insert into t1 values(2,1,1);
--real_sleep 1
insert into t1 values(2,2,1);
--real_sleep 1

connection conn1;
begin;
update t1 set a=a+1 where f1=1 and f2=1;
--real_sleep 1
update t1 set a=a+1 where f1=2 and f2=1;
--real_sleep 1

connection conn2;
begin;
update t1 set a=a+1 where f1=1 and f2=2;
--real_sleep 1
update t1 set a=a+1 where f1=2 and f2=2;
--real_sleep 1

connection conn1;
commit;
connection conn2;
commit;
--real_sleep 1

--echo -- expect (1,1,2),(1,2,2),(2,1,2),(2,2,2)
--real_sleep 1
select * from t1;

connection conn1;
begin;
update t1 set a=a+1 where f1=1 and f2=1;
--real_sleep 1
update t1 set a=a+1 where f1=2 and f2=2;
--real_sleep 1
connection conn3;
begin;
update t1 set a=a+1 where f1=2 and f2=1;
--real_sleep 1
connection conn2;
begin;
update t1 set a=a+1 where f1=1 and f2=2;
--real_sleep 1
--error 5049
update t1 set a=a+1 where f1=1 and f2=1;
--real_sleep 1
ROLLBACK;

connection conn1;
commit;
connection conn3;
commit;
--echo -- expect (1,1,3),(1,2,2),(2,1,3),(2,2,3)
--real_sleep 1
select * from t1;

connection conn1;
begin;
--echo --rowkey is required
update t1 set a=a+1 where f1=1;
--real_sleep 1
ROLLBACK;

--echo -- expect (1,1,3),(1,2,2),(2,1,3),(2,2,3)
select * from t1;

drop table t1;
drop partition function h2;
--echo ###################

###2-5:在list分区规则下，发起多个会话窗口执行事务
create table t1 (f1 int, f2 varchar(30),a int, primary key(f1,f2)) partition by list columns(f1,f2)(partition r1 values in((1,'1'),(1,'2')),partition r2 values in ((2,'1'),(2,'2')));
--real_sleep 1
insert into t1 values(1,'1',1);
--real_sleep 1
insert into t1 values(1,'2',1);
--real_sleep 1
insert into t1 values(2,'1',1);
--real_sleep 1
insert into t1 values(2,'2',1);

--real_sleep 1

connection conn1;
begin;
update t1 set a=a+1 where f1=1 and f2='1';
--real_sleep 1
update t1 set a=a+1 where f1=2 and f2='1';
--real_sleep 1

connection conn2;
begin;
update t1 set a=a+1 where f1=1 and f2='2';
--real_sleep 1
update t1 set a=a+1 where f1=2 and f2='2';
--real_sleep 1
connection conn1;
commit;
connection conn2;
commit;
--real_sleep 1
--echo -- expect (1,'1',2),(1,'2',2),(2,'1',2),(2,'2',2)
select * from t1;

connection conn1;
begin;
update t1 set a=a+1 where f1=1 and f2='1';
--real_sleep 1
update t1 set a=a+1 where f1=2 and f2='2';
--real_sleep 1
connection conn3;
begin;
update t1 set a=a+1 where f1=2 and f2='1';
--real_sleep 1

connection conn2;
begin;
update t1 set a=a+1 where f1=1 and f2='2';
--error 5049
update t1 set a=a+1 where f1=1 and f2='1';
ROLLBACK;
--real_sleep 2
connection conn1;
commit;
connection conn3;
commit;
--echo -- expect (1,'1',3),(1,'2',2),(2,'1',3),(2,'2',3)
select * from t1;

connection conn1;
begin;
--echo --rowkey is required
update t1 set a=a+1 where f1=1;
ROLLBACK;

--echo -- expect (1,'1',3),(1,'2',2),(2,'1',3),(2,'2',3)
select * from t1;
drop table t1;
--real_sleep 1

--echo ################### update more columns
create table t1 (f1 int, f2 varchar(30),a int, b int, primary key(f1,f2)) partition by list columns(f1,f2)(partition q1 values in((1,'1'),(1,'2')),partition q2 values in ((2,'1'),(2,'2')));
--real_sleep 1
insert into t1 values(1,'1',1,0);
--real_sleep 1
insert into t1 values(1,'2',1,0);
--real_sleep 1
insert into t1 values(2,'1',1,0);
--real_sleep 1
insert into t1 values(2,'2',1,0);
--real_sleep 1
connection conn1;
begin;
update t1 set a=a+1,b=b-1 where f1=1 and f2='1';
update t1 set a=a+1,b=b-1 where f1=2 and f2='1';

connection conn2;
begin;
update t1 set a=a+1,b=b-1 where f1=1 and f2='2';
update t1 set a=a+1,b=b-1 where f1=2 and f2='2';

connection conn1;
commit;
connection conn2;
commit;
--real_sleep 1
--echo -- expect (1,'1',2,-1),(1,'2',2,-1),(2,'1',2,-1),(2,'2',2,-1)
select * from t1;

connection conn1;
begin;
update t1 set a=a+1,b=b-1 where f1=1 and f2='1';
update t1 set a=a+1,b=b-1 where f1=2 and f2='2';
--real_sleep 1
connection conn3;
begin;
update t1 set a=a+1,b=b-1 where f1=2 and f2='1';
--real_sleep 1
connection conn2;
begin;
update t1 set a=a+1,b=b-1 where f1=1 and f2='2';
--error 5049
update t1 set a=a+1,b=b-1 where f1=1 and f2='1';
--real_sleep 1
ROLLBACK;

connection conn1;
commit;
connection conn3;
commit;
--real_sleep 1
--echo -- expect (1,'1',3,-2),(1,'2',2,-1),(2,'1',3,-2),(2,'2',3,-2)
select * from t1;

drop table t1;
